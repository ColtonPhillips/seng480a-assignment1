/* Verifier.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

#include "ClassFileFormat.h"
#include "OpcodeSignatures.h"
#include "TraceOptions.h"
#include "MyAlloc.h"
#include "VerifierUtils.h"
#include "Verifier.h"

#define MAX_NUMBER_OF_SLOTS 20
#define MAX_BUFFER_SIZE 200

// Output an array of the verifier's type descriptors
static void printTypeCodesArray( char **vstate, method_info *m, char *name ) {
    int i;
    if (name != NULL)
        fprintf(stdout, "\nMethod %s:\n", name);
    else
        fputc('\n', stdout);
    for( i = 0;  i < m->max_locals; i++ ) {
        fprintf(stdout, "  V%d:  %s\n", i, *vstate++);
    }
    for( i = 0;  i < m->max_stack; i++ )
        fprintf(stdout, "  S%d:  %s\n", i, *vstate++);
}

typedef struct {
	int	bytecodePosition;
	int	changed;
	int	stackHeight;
	char	typecodeList[MAX_NUMBER_OF_SLOTS][MAX_BUFFER_SIZE];
} deet;

void print_deet(deet* d) {

	int i = 0;

	printf("[deet %lu] position: %i, changed: %i, stack height: %i\n", (unsigned long)d, d->bytecodePosition, d->changed, d->stackHeight);
	for (i = 0; i < MAX_NUMBER_OF_SLOTS; ++i) {
		printf("\t%i:	%s\n", i, d->typecodeList[i]);
	}
}

void initialize_deet(int bytecodePosition, deet* d) {

	int i = 0;

	d->bytecodePosition = bytecodePosition;
	d->changed = 0;
	d->stackHeight = -1;

	for (i = 0; i < MAX_NUMBER_OF_SLOTS; ++i) {
		strcpy(d->typecodeList[i], "?");
	}
}


// Verify the bytecode of one method m from class file cf
static void verifyMethod( ClassFile *cf, method_info *m ) {
    char *name = GetCPItemAsString(cf, m->name_index);
    char *retType;
    int numSlots = m->max_locals + m->max_stack;

    // initState is an array of strings, it has numSlots elements
    // retType describes the result type of this method
    char **initState = MapSigToInitState(cf, m, &retType);

    if (tracingExecution & TRACE_VERIFY)
    	printTypeCodesArray(initState, m, name);

    // Your code to verify the bytecode of the current method
    // begins here.

    // Feel free to define and use as many extra functions as
    // are appropriate for this problem.

    // Do include tracing output statements in your code
    // controlled by the tracingExecution variable to help
    // you debug the verification algorithm.
    
    // Sratch variables
    int i = 0;
  
    // Initialize D to <0, 1, intial stack height, initial typecode list>;
    deet* deets = (deet*)malloc(sizeof(deet) * m->code_length);
    for (i = 0; i < m->code_length; ++i) {
	    initialize_deet(i, deets + i);
    }

    // while D contains an entry with a set change bit do
    //         set change bit to 0 in this entry;
    // p = bytecode position in this entry;
    // h = stack height in this entry;
    // t = typecode list in this entry;
    // op = opcode at position p in byecode;
    // if op comtains any immediate operands then
    //         check that any operands which are indexes are in range;
    // foreach stack operand accessed by op do
    //         decrement h and check that stack does not underflow;
    // pop stack t and check datatype compatibility of that operand;
    // foreach stack result generated by op do
    //         increment h and check that stack does not overflow;
    // push typecode of result onto the stack t;
    // for q = the bytecode position of each instruction that
    //         can execute immediately after op at position p do
    //     	    if an entry with position q exists in D then
    //     		    merge h and t with the entry in D, updating that entry;
    // if any incompatibilities were found then
    //         report an error;
    // if anything changed in that entry then
    //         set its change bit;
    // else // no q entry exists
    // add a new entry <q, 1, h, t> to D

    free(deets);
    FreeTypeDescriptorArray(initState, numSlots);
    SafeFree(name);
}


// Verify the bytecode of all methods in class file cf
void Verify( ClassFile *cf ) {
    int i;

    for( i = 0;  i < cf->methods_count;  i++ ) {
        method_info *m = &(cf->methods[i]);
	    verifyMethod(cf, m);
    }
    if (tracingExecution & TRACE_VERIFY)
    	fprintf(stdout, "Verification of class %s completed\n\n", cf->cname);
}


// Initialize this module
void InitVerifier(void) {
#ifndef NDEBUG
    // perform integrity check on the opcode table
    CheckOpcodeTable();
#endif
    // any initialization of local data structures can go here
}
